package ch.globaz.amal.process.repriseDecisionsTaxations.step4;

import globaz.globall.util.JADate;
import globaz.globall.util.JAException;
import globaz.globall.util.JANumberFormatter;
import globaz.jade.client.util.JadeStringUtil;
import globaz.jade.context.JadeThread;
import globaz.jade.context.exception.JadeNoBusinessLogSessionError;
import globaz.jade.exception.JadeApplicationException;
import globaz.jade.exception.JadePersistenceException;
import globaz.jade.persistence.model.JadeAbstractModel;
import globaz.jade.service.provider.application.util.JadeApplicationServiceNotAvailableException;
import globaz.pyxis.util.TINSSFormater;
import java.io.StringReader;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.stream.StreamSource;
import ch.globaz.amal.business.calcul.CalculsRevenuFormules;
import ch.globaz.amal.business.calcul.CalculsSubsidesContainer;
import ch.globaz.amal.business.constantes.IAMCodeSysteme;
import ch.globaz.amal.business.constantes.IAMCodeSysteme.AMDocumentModeles;
import ch.globaz.amal.business.constantes.IAMParametresAnnuels;
import ch.globaz.amal.business.exceptions.models.detailFamille.DetailFamilleException;
import ch.globaz.amal.business.exceptions.models.revenu.RevenuException;
import ch.globaz.amal.business.models.contribuable.SimpleContribuable;
import ch.globaz.amal.business.models.controleurEnvoi.ComplexControleurEnvoiDetail;
import ch.globaz.amal.business.models.controleurEnvoi.ComplexControleurEnvoiDetailSearch;
import ch.globaz.amal.business.models.detailfamille.SimpleDetailFamille;
import ch.globaz.amal.business.models.detailfamille.SimpleDetailFamilleSearch;
import ch.globaz.amal.business.models.famille.SimpleFamille;
import ch.globaz.amal.business.models.famille.SimpleFamilleSearch;
import ch.globaz.amal.business.models.revenu.Revenu;
import ch.globaz.amal.business.models.revenu.RevenuFullComplex;
import ch.globaz.amal.business.models.revenu.RevenuHistoriqueComplex;
import ch.globaz.amal.business.models.revenu.RevenuHistoriqueComplexSearch;
import ch.globaz.amal.business.models.revenu.RevenuSearch;
import ch.globaz.amal.business.models.uploadfichierreprise.SimpleUploadFichierReprise;
import ch.globaz.amal.business.services.AmalServiceLocator;
import ch.globaz.amal.businessimpl.services.AmalImplServiceLocator;
import ch.globaz.amal.businessimpl.utils.parametres.ContainerParametres;
import ch.globaz.amal.process.repriseDecisionsTaxations.AMProcessRepriseDecisionsTaxationsEnum;
import ch.globaz.jade.process.business.bean.JadeProcessEntity;
import ch.globaz.jade.process.business.interfaceProcess.entity.JadeProcessEntityInterface;
import ch.globaz.jade.process.business.interfaceProcess.entity.JadeProcessEntityNeedProperties;
import ch.globaz.pyxis.business.model.PersonneEtendueComplexModel;
import ch.globaz.pyxis.business.service.TIBusinessServiceLocator;

public class AMProcessRepriseDecisionsTaxationsEntityHandler implements JadeProcessEntityInterface,
        JadeProcessEntityNeedProperties {
    private ContainerParametres containerParametres = null;
    private ch.globaz.amal.xmlns.am_0001._1.Personne currentContribuableConjoint;
    private ch.globaz.amal.xmlns.am_0001._1.Contribuables currentContribuables = null;
    private String currentTypeContribuable = null;
    private String idContribuable = null;
    private boolean isMemberBornAfterFiscalPeriode = false;
    private boolean isRepriseNonTaxes = false;
    private Map<String, ch.globaz.amal.xmlns.am_0001._1.Taxation> mapTaxation = null;
    private Map<Enum<?>, String> properties = null;
    private Unmarshaller unmarshaller = null;
    private int yearTaxation = 0;
    private int yearSubside = 0;

    public AMProcessRepriseDecisionsTaxationsEntityHandler(ContainerParametres container, Unmarshaller _unmarshaller,
            String _idJob) {
        unmarshaller = _unmarshaller;
        containerParametres = container;
    }

    private String _searchDocumentTemp(String id, String anneeHist, String idDetailFamille)
            throws JadeApplicationServiceNotAvailableException, JadePersistenceException {
        ComplexControleurEnvoiDetailSearch complexControleurEnvoiDetailSearch = new ComplexControleurEnvoiDetailSearch();
        complexControleurEnvoiDetailSearch.setForAnneeHistorique(anneeHist);
        complexControleurEnvoiDetailSearch.setForIdFamille(id);
        ArrayList<String> arrayStatus = new ArrayList<String>();
        arrayStatus.add(IAMCodeSysteme.AMDocumentStatus.AUTOGENERATED.getValue());
        arrayStatus.add(IAMCodeSysteme.AMDocumentStatus.MANUALGENERATED.getValue());
        complexControleurEnvoiDetailSearch.setInStatusEnvoi(arrayStatus);
        complexControleurEnvoiDetailSearch = AmalServiceLocator.getControleurEnvoiService().search(
                complexControleurEnvoiDetailSearch);

        if (complexControleurEnvoiDetailSearch.getSize() > 0) {
            // On prend le dernier document généré
            int size = complexControleurEnvoiDetailSearch.getSize();
            ComplexControleurEnvoiDetail complexControleurEnvoiDetail = (ComplexControleurEnvoiDetail) complexControleurEnvoiDetailSearch
                    .getSearchResults()[size - 1];

            if (!complexControleurEnvoiDetail.getIdDetailFamille().equals(idDetailFamille)) {
                return complexControleurEnvoiDetail.getNumModele();
            }
        }
        return "";
    }

    /**
     * @param idTaxation
     * @param anneeHistoriqueTaxation
     * @return
     * @throws RevenuException
     * @throws JadeApplicationServiceNotAvailableException
     * @throws JadePersistenceException
     */
    private int calculRevDet(String idTaxation, BigInteger anneeHistoriqueTaxation) throws RevenuException,
            JadeApplicationServiceNotAvailableException, JadePersistenceException {

        RevenuFullComplex revenuFullComplex = AmalServiceLocator.getRevenuService().readFullComplex(idTaxation);
        RevenuHistoriqueComplex revenuHistorique = new RevenuHistoriqueComplex();
        revenuHistorique.setRevenuFullComplex(revenuFullComplex);

        BigInteger anneeHistorique = anneeHistoriqueTaxation;
        revenuHistorique.getSimpleRevenuHistorique().setAnneeHistorique(anneeHistorique.toString());
        revenuHistorique.setRevenuFullComplex(revenuHistorique.getRevenuFullComplex());
        CalculsRevenuFormules calculsRevenuFormules = new CalculsRevenuFormules();
        try {
            revenuHistorique = calculsRevenuFormules.doCalcul(revenuHistorique);
        } catch (Exception ex) {
            JadeThread.logError("ERREUR REVENU DETERMINANT", "ERREUR CALCUL REVENU DETERMINANT ==>" + ex.getMessage()
                    + ";");
            return 0;
        }
        if (revenuHistorique == null) {
            JadeThread.logInfo("CALCUL", "Pas de calcul du revenu possible !;");
            return 0;
        }
        BigInteger revenuDeterminant = new BigInteger(revenuHistorique.getSimpleRevenuDeterminant()
                .getRevenuDeterminantCalcul());

        return revenuDeterminant.intValue();

    }

    /**
     * @param simpleFamille
     * @param yearPeriode
     * @return
     * @throws JAException
     */
    private int checkAge(SimpleFamille simpleFamille, BigInteger yearPeriode) throws JAException {
        String dateNaissance = simpleFamille.getDateNaissance();
        JADate date = new JADate(dateNaissance);
        int yearDateNaissance = date.getYear();

        int agePersonne = yearPeriode.intValue() - yearDateNaissance;

        return agePersonne;
    }

    /**
     * Teste si les membres qui ont un DECMST1 ou DECMST8 ont un assureur. Si pas d'assureur, on n'envoie des ATSUBS, ou
     * ATENF, à la place
     * 
     * @param isPersChargeSelon620
     * @param familleModeste
     * @param familleMoyenne
     * @param noCaisseMaladieByMembre
     * @param mapFamilyMember
     * @param mapMembreModels
     * @param idFamilleContribuable
     * @throws JadeNoBusinessLogSessionError
     */
    private void checkDECMST1Or8HasCM(boolean isPersChargeSelon620, boolean familleModeste, boolean familleMoyenne,
            Map<String, String> noCaisseMaladieByMembre, Map<String, SimpleFamille> mapFamilyMember,
            Map<String, AMDocumentModeles> mapMembreModels, String idFamilleContribuable)
            throws JadeNoBusinessLogSessionError {
        for (String id : noCaisseMaladieByMembre.keySet()) {
            String noCaisse = noCaisseMaladieByMembre.get(id);
            if (noCaisse == null) {
                try {
                    if (familleModeste) {
                        SimpleFamille membre = mapFamilyMember.get(id);
                        AMDocumentModeles atsubs = checkTypeATSUB(membre, isPersChargeSelon620);
                        for (String id2 : mapMembreModels.keySet()) {
                            if (idFamilleContribuable.equals(id)) {
                                mapMembreModels.put(id2, atsubs);
                            } else {
                                mapMembreModels.put(id2, null);
                            }
                        }
                        JadeThread.logInfo("INFO", "Documents remplacés par ATSUBS car membre sans assureur !");
                        break;
                    } else if (familleMoyenne) {
                        for (String id2 : mapMembreModels.keySet()) {
                            mapMembreModels.put(id2, AMDocumentModeles.ATENF8);
                        }
                        JadeThread.logInfo("INFO", "DECMST8 remplacé par ATENF8 car enfant sans assureur !");
                        break;
                    }
                } catch (Exception e) {
                    JadeThread
                            .logError("ERROR", "Erreur lors du remplacement du document d'un membre sans assurance !");
                }
            }
        }
    }

    private void checkFamilleModestDocumentOnContribPrincipal(Map<String, AMDocumentModeles> mapMembreModels,
            String idFamilleContribuable) throws JadeNoBusinessLogSessionError {
        boolean isModelOnContribuable = true;
        try {
            AMDocumentModeles modelContribuable = mapMembreModels.get(idFamilleContribuable);
            if (modelContribuable == null) {
                isModelOnContribuable = false;
            }
        } catch (Exception ex) {
            isModelOnContribuable = false;
        }
        if (!isModelOnContribuable) {
            JadeThread
                    .logInfo("INFO",
                            "Famille modeste (<33000) sans document sur le contribuable principal ! Aucune attribution effectuée !");
            mapMembreModels.clear();
        }
    }

    private boolean checkIfEtatCivilChanged(ch.globaz.amal.xmlns.am_0001._1.Taxation taxationXml, boolean ecChanged,
            BigInteger anneeTaxation) {
        Revenu revenuAnneePrec = findRevenuAnneePrec(anneeTaxation.subtract(new BigInteger("1")).toString());
        if (revenuAnneePrec != null) {
            String ecTax = getCsEtatCivil(taxationXml.getEcTax().intValue());

            // Si l'EC du revenu précédent est concubin, l'etat civil ne change que si le nouveau est
            // "Marié"
            if (revenuAnneePrec.getEtatCivil().equals(IAMCodeSysteme.CS_ETAT_CIVIL_CONCUBIN)) {
                if (ecTax.equals(IAMCodeSysteme.CS_ETAT_CIVIL_CELIBATAIRE)
                        || ecTax.equals(IAMCodeSysteme.CS_ETAT_CIVIL_VEUF)
                        || ecTax.equals(IAMCodeSysteme.CS_ETAT_CIVIL_SEPARE)
                        || ecTax.equals(IAMCodeSysteme.CS_ETAT_CIVIL_DIVORCE)
                        || ecTax.equals(IAMCodeSysteme.CS_ETAT_CIVIL_HOIRIE)) {
                    ecChanged = false;
                } else if (ecTax.equals(IAMCodeSysteme.CS_ETAT_CIVIL_MARIED)) {
                    ecChanged = true;
                }

            } else {
                // On ne considère pas un passage "Séparé" --> "Divorcé" comme changement d'EC
                if ((revenuAnneePrec.getEtatCivil().equals(IAMCodeSysteme.CS_ETAT_CIVIL_SEPARE) || revenuAnneePrec
                        .getEtatCivil().equals(IAMCodeSysteme.CS_ETAT_CIVIL_DIVORCE))
                        && (ecTax.equals(IAMCodeSysteme.CS_ETAT_CIVIL_SEPARE) || ecTax
                                .equals(IAMCodeSysteme.CS_ETAT_CIVIL_DIVORCE))) {
                    ecChanged = false;
                } else {
                    if (!revenuAnneePrec.getEtatCivil().equals(ecTax)) {
                        ecChanged = true;
                    }
                }
            }
        } else {
            ecChanged = false;
        }
        return ecChanged;
    }

    private boolean checkMemberHasAlreadySubside(SimpleDetailFamille detailFamille, SimpleFamille simpleFamille)
            throws DetailFamilleException {
        try {
            String noAVS = "";
            String idTiers = "";
            String nomPrenom = "";

            if (!simpleFamille.isNew()) {
                noAVS = simpleFamille.getNoAVS();
                idTiers = simpleFamille.getIdTier();
                nomPrenom = simpleFamille.getNomPrenom();
            }

            if (JadeStringUtil.isBlankOrZero(noAVS)) {

                if (JadeStringUtil.isBlankOrZero(idTiers)) {
                    JadeThread
                            .logWarn(
                                    detailFamille.getClass().getName(),
                                    "Membre famille ('"
                                            + simpleFamille.getNomPrenom()
                                            + "') sans idTiers ni NNSS, impossible de retrouver si un autre subside est présent");
                    return false;
                }
                PersonneEtendueComplexModel personneEtendueComplexModel = TIBusinessServiceLocator
                        .getPersonneEtendueService().read(simpleFamille.getIdTier());
                noAVS = personneEtendueComplexModel.getPersonneEtendue().getNumAvsActuel();
                nomPrenom = personneEtendueComplexModel.getTiers().getDesignation1() + " "
                        + personneEtendueComplexModel.getTiers().getDesignation2();
            }

            ArrayList<String> idFamilleCorresp = new ArrayList<String>();
            if (JadeStringUtil.isBlankOrZero(noAVS)) {
                JadeThread.logWarn(detailFamille.getClass().getName(),
                        "Pas de NNSS au tiers (" + simpleFamille.getNomPrenom()
                                + "), impossible de retrouver si un autre subside est présent");
            } else {
                SimpleFamilleSearch simpleFamilleSearch = new SimpleFamilleSearch();
                if (!JadeStringUtil.isBlankOrZero(simpleFamille.getIdTier())) {
                    simpleFamilleSearch.setForIdTiers(simpleFamille.getIdTier());
                } else {
                    simpleFamilleSearch.setLikeNoAVS(JadeStringUtil.removeChar(noAVS, '.'));
                }
                simpleFamilleSearch = AmalImplServiceLocator.getSimpleFamilleService().search(simpleFamilleSearch);

                for (JadeAbstractModel sfModel : simpleFamilleSearch.getSearchResults()) {
                    SimpleFamille sf = (SimpleFamille) sfModel;

                    idFamilleCorresp.add(sf.getIdFamille());
                }
            }

            for (String id : idFamilleCorresp) {
                SimpleDetailFamilleSearch detailFamilleSearch = new SimpleDetailFamilleSearch();
                detailFamilleSearch.setForIdFamille(id);
                detailFamilleSearch.setForAnneeHistorique(detailFamille.getAnneeHistorique());
                detailFamilleSearch = AmalImplServiceLocator.getSimpleDetailFamilleService()
                        .search(detailFamilleSearch);

                for (JadeAbstractModel sdf_model : detailFamilleSearch.getSearchResults()) {
                    SimpleDetailFamille sdf = (SimpleDetailFamille) sdf_model;

                    if (!sdf.getIdFamille().equals(detailFamille.getIdFamille()) && sdf.getCodeActif()
                            && JadeStringUtil.isBlankOrZero(sdf.getFinDroit())) {

                        if (isDocumentAttrib(sdf.getNoModeles())) {

                            try {
                                // On recherche le nom du contribuable pour afficher dans la bubulle d'erreur
                                SimpleFamilleSearch sfContriSearch = AmalImplServiceLocator.getSimpleFamilleService()
                                        .getChefDeFamille(sdf.getIdContribuable());
                                SimpleFamille membreContri = new SimpleFamille();
                                SimpleContribuable contrib = new SimpleContribuable();
                                if (sfContriSearch.getSize() > 0) {
                                    membreContri = (SimpleFamille) sfContriSearch.getSearchResults()[0];
                                    contrib = AmalImplServiceLocator.getSimpleContribuableService().read(
                                            membreContri.getIdContribuable());
                                }

                                if (membreContri.isNew()) {
                                    JadeThread.logWarn(detailFamille.getClass().getName(),
                                            "Un subside existe déjà pour ce membre  (" + nomPrenom + " - "
                                                    + getCurrentValidFormattedNSS(noAVS) + ")");
                                    return true;
                                } else {
                                    JadeThread.logWarn(detailFamille.getClass().getName(),
                                            "Un subside existe déjà pour ce membre : " + nomPrenom + " "
                                                    + getCurrentValidFormattedNSS(noAVS) + " sur le contribuable : "
                                                    + formatNoContribuable(contrib.getNoContribuable()) + " - "
                                                    + membreContri.getNomPrenom());
                                    return true;
                                }
                            } catch (Exception e) {
                                JadeThread.logWarn(detailFamille.getClass().getName(),
                                        "Un subside existe déjà pour un membre ==> " + e.getMessage());
                                return true;
                            }
                        }
                    }
                }
                String noModelTemp = _searchDocumentTemp(id, detailFamille.getAnneeHistorique(),
                        detailFamille.getIdDetailFamille());

                if (isDocumentAttrib(noModelTemp)) {
                    JadeThread.logWarn(detailFamille.getClass().getName(),
                            "Un subside non envoyé existe déjà pour ce NNSS  (" + noAVS + ")");
                    return true;
                }

            }
            return false;
        } catch (Exception e) {
            throw new DetailFamilleException(e.getMessage());
        }

    }

    private String checkTempModel(BigInteger anneeSubsideToSearch, SimpleFamille membreFamille, String noModelTemp)
            throws JadePersistenceException, JadeApplicationServiceNotAvailableException {
        ComplexControleurEnvoiDetailSearch complexControleurEnvoiDetailSearch = new ComplexControleurEnvoiDetailSearch();
        complexControleurEnvoiDetailSearch.setForAnneeHistorique(anneeSubsideToSearch.toString());
        complexControleurEnvoiDetailSearch.setForIdFamille(membreFamille.getIdFamille());
        complexControleurEnvoiDetailSearch
                .setForStatusEnvoi(IAMCodeSysteme.AMDocumentStatus.MANUALGENERATED.getValue());
        complexControleurEnvoiDetailSearch = AmalServiceLocator.getControleurEnvoiService().search(
                complexControleurEnvoiDetailSearch);

        if (complexControleurEnvoiDetailSearch.getSize() > 0) {
            // On prend le dernier document généré
            int size = complexControleurEnvoiDetailSearch.getSize();
            ComplexControleurEnvoiDetail complexControleurEnvoiDetail = (ComplexControleurEnvoiDetail) complexControleurEnvoiDetailSearch
                    .getSearchResults()[size - 1];

            String modele = complexControleurEnvoiDetail.getNumModele();
            if (modele.equals(IAMCodeSysteme.AMDocumentModeles.DECMST1.getValue())
                    || modele.equals(IAMCodeSysteme.AMDocumentModeles.DECMST2.getValue())
                    || modele.equals(IAMCodeSysteme.AMDocumentModeles.DECMST3.getValue())
                    || modele.equals(IAMCodeSysteme.AMDocumentModeles.DECMST5.getValue())
                    || modele.equals(IAMCodeSysteme.AMDocumentModeles.DECMST8.getValue())
                    || modele.equals(IAMCodeSysteme.AMDocumentModeles.DECMASB.getValue())
                    || modele.equals(IAMCodeSysteme.AMDocumentModeles.DECMST10.getValue())
                    || modele.equals(IAMCodeSysteme.AMDocumentModeles.DECMST11.getValue())
                    || modele.equals(IAMCodeSysteme.AMDocumentModeles.DECMPCE.getValue())
                    || AMDocumentModeles.ATENF8.getValue().equals(modele)
                    || AMDocumentModeles.ATENF1.getValue().equals(modele)) {
                noModelTemp = modele;
            }
        }
        return noModelTemp;
    }

    /**
     * @param membreFamille
     * @param hasEnfantsCharge
     * @return
     */
    private AMDocumentModeles checkTypeATSUB(SimpleFamille membreFamille, boolean hasEnfantsCharge) {
        if (!membreFamille.getPereMereEnfant().equals(IAMCodeSysteme.CS_TYPE_ENFANT)
                && isPersonneSeule(hasEnfantsCharge)) {
            return AMDocumentModeles.ATSUBS1;
        } else {
            if (!membreFamille.getPereMereEnfant().equals(IAMCodeSysteme.CS_TYPE_ENFANT)) {
                if (hasEnfantsCharge) {
                    return AMDocumentModeles.ATSUBS2;
                } else {
                    return AMDocumentModeles.ATSUBS3;
                }
            } else {
                return null;
            }
        }
    }

    /**
     * @return
     */
    private boolean conjointValideExist() {
        if (!(currentContribuableConjoint == null)) {
            String dateDeces = currentContribuableConjoint.getDateDeces();
            String ndcConj = currentContribuableConjoint.getNdcConj();
            if (JadeStringUtil.isBlankOrZero(dateDeces) && JadeStringUtil.isBlankOrZero(ndcConj)) {
                return true;
            }
        }

        return false;
    }

    private Revenu findRevenuAnneePrec(String anneeTaxationPrecedente) {
        try {
            RevenuSearch revenuSearch = new RevenuSearch();
            revenuSearch.setForIdContribuable(idContribuable);
            revenuSearch.setForAnneeTaxation(anneeTaxationPrecedente);
            revenuSearch.setForTypeRevenu(IAMCodeSysteme.CS_TYPE_CONTRIBUABLE);
            ArrayList<String> listeTypesTaxation = new ArrayList<String>();
            listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.ORDINAIRE.getValue());
            listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.OFFICE_TOTAUX.getValue());
            listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.DECISION_NVL.getValue());
            listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.DECISION_RCL.getValue());
            listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.DECISION_REC.getValue());
            listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.OFFICE_DETAIL.getValue());
            listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.RECTIFICATION.getValue());
            listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.RAPPEL_IMPOT.getValue());
            listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.REVISION_TAX.getValue());
            revenuSearch.setInTypeTaxation(listeTypesTaxation);
            revenuSearch = AmalServiceLocator.getRevenuService().search(revenuSearch);

            if (revenuSearch.getSize() > 0) {
                return (Revenu) revenuSearch.getSearchResults()[0];
            }
        } catch (Exception e) {
            JadeThread.logError("ERROR", "Erreur lors de la recherche de la taxation de l'année précédente ("
                    + anneeTaxationPrecedente + ");");
            return null;
        }

        return null;
    }

    /**
     * format le numéro au format : xxx.xxx.xxx.xx
     */
    private String formatNoContribuable(String val) {
        if (val == null) {
            return "";
        }

        String str = "";
        for (int i = 0; i < val.length(); i++) {
            str += val.charAt(i);

            switch (i) {
                case 2:
                case 5:
                case 8:
                    str += ".";
                    break;
            }
        }

        return str;
    }

    private String getCsEtatCivil(int etatCivil) {
        String etatCivilCS = "";
        switch (etatCivil) {
            case 1:
                etatCivilCS = IAMCodeSysteme.CS_ETAT_CIVIL_CELIBATAIRE;
                break;
            case 2:
                etatCivilCS = IAMCodeSysteme.CS_ETAT_CIVIL_MARIED;
                break;
            case 3:
                etatCivilCS = IAMCodeSysteme.CS_ETAT_CIVIL_VEUF;
                break;
            case 4:
                etatCivilCS = IAMCodeSysteme.CS_ETAT_CIVIL_DIVORCE;
                break;
            case 5:
                etatCivilCS = IAMCodeSysteme.CS_ETAT_CIVIL_SEPARE;
                break;
            case 9:
                etatCivilCS = IAMCodeSysteme.CS_ETAT_CIVIL_HOIRIE;
                break;
            default:
                etatCivilCS = "0";
                break;
        }

        return etatCivilCS;
    }

    /**
     * Récupération du nss formatté
     * 
     * @return
     */
    private String getCurrentValidFormattedNSS(String val) {
        String currentNSS = "";
        // ------------------------------------------------------------------------------------
        // Récupération du noAVS
        // ------------------------------------------------------------------------------------
        if (!JadeStringUtil.isBlankOrZero(val)) {
            try {
                String nssFormatted = TINSSFormater.format(val, TINSSFormater.findType(val));
                currentNSS = nssFormatted;
            } catch (Exception e) {
                currentNSS = val;
            }
        } else {
            currentNSS = "";
        }
        return currentNSS;
    }

    private void getLastAttribution(boolean familleModeste, boolean familleMoyenne,
            Map<String, String> noCaisseMaladieByMembre, Map<String, String> subsidesByFamilyMember,
            Map<String, SimpleFamille> mapFamilyMember, SimpleFamille membreFamille, String idFamille, int ageMembre,
            SimpleDetailFamilleSearch detailFamilleSearch, String noModelTemp) throws JadeNoBusinessLogSessionError {
        if (detailFamilleSearch.getSize() == 0) {
            // si c'est un contribuable de moins de 26 ans et qu'il n'a pas encore de subside
            // attribué, on ne fait rien
            if ((ageMembre < 26) && membreFamille.getIsContribuable()) {
                JadeThread.logInfo("INFO", "Membre famille < 25 ans !;");
                return;
            }
            subsidesByFamilyMember.put(idFamille, "NONE");
            mapFamilyMember.put(idFamille, membreFamille);
        } else {
            SimpleDetailFamille subsideAnneePrecedente = (SimpleDetailFamille) detailFamilleSearch.getSearchResults()[0];
            String typeDemande = subsideAnneePrecedente.getTypeDemande();

            // On ne traite que s'il s'agit d'une demande ou d'un reprise auto
            if (typeDemande.equals(IAMCodeSysteme.AMTypeDemandeSubside.DEMANDE.getValue())
                    || typeDemande.equals(IAMCodeSysteme.AMTypeDemandeSubside.REPRISE.getValue())) {
                boolean onlyChild = false;
                if (familleMoyenne && membreFamille.getPereMereEnfant().equals(IAMCodeSysteme.CS_TYPE_ENFANT)) {
                    onlyChild = true;
                }

                String noCM = subsideAnneePrecedente.getNoCaisseMaladie();
                if (familleModeste || onlyChild || isRepriseNonTaxes) {
                    String noModel = subsideAnneePrecedente.getNoModeles();
                    // Si noModelTemp != null c'est qu'on a un document temporaire, on utilise
                    // celui-la
                    if (noModelTemp != null) {
                        noModel = noModelTemp;
                    }
                    if (((noModel.equals(IAMCodeSysteme.AMDocumentModeles.DECMST1.getValue())
                            || noModel.equals(IAMCodeSysteme.AMDocumentModeles.DECMST2.getValue())
                            || noModel.equals(IAMCodeSysteme.AMDocumentModeles.DECMST3.getValue())
                            || noModel.equals(IAMCodeSysteme.AMDocumentModeles.DECMST5.getValue())
                            || noModel.equals(IAMCodeSysteme.AMDocumentModeles.DECMST8.getValue())
                            || noModel.equals(IAMCodeSysteme.AMDocumentModeles.DECMASB.getValue())
                            || noModel.equals(IAMCodeSysteme.AMDocumentModeles.DECMST10.getValue())
                            || noModel.equals(IAMCodeSysteme.AMDocumentModeles.DECMST11.getValue())
                            || noModel.equals(IAMCodeSysteme.AMDocumentModeles.DECMPCE.getValue()))
                            && !IAMCodeSysteme.AMCodeTraitementDossier.INCOMPLET.getValue().equals(subsideAnneePrecedente.getCodeTraitementDossier()))
                            || AMDocumentModeles.ATENF8.getValue().equals(noModel)
                            || AMDocumentModeles.ATENF1.getValue().equals(noModel)) {
                        subsidesByFamilyMember.put(idFamille, noModel);
                        mapFamilyMember.put(idFamille, membreFamille);
                        if (!JadeStringUtil.isBlankOrZero(noCM)) {
                            noCaisseMaladieByMembre.put(idFamille, noCM);
                        } else {
                            noCaisseMaladieByMembre.put(idFamille, null);
                        }

                    } else {
                        subsidesByFamilyMember.put(idFamille, "OTHER");
                        mapFamilyMember.put(idFamille, membreFamille);
                    }
                }
            } else {
                subsidesByFamilyMember.put(idFamille, "PC_ASSISTE");
                mapFamilyMember.put(idFamille, membreFamille);
                if (typeDemande.equals(IAMCodeSysteme.AMTypeDemandeSubside.ASSISTE.getValue())) {
                    JadeThread.logInfo("Subside", "Dossier assisté ! ==>" + membreFamille.getNomPrenom() + ";");
                } else if (typeDemande.equals(IAMCodeSysteme.AMTypeDemandeSubside.PC.getValue())) {
                    JadeThread.logInfo("Subside", "Dossier PC ! ==>" + membreFamille.getNomPrenom() + ";");
                } else if (typeDemande.equals(IAMCodeSysteme.AMTypeDemandeSubside.SOURCE.getValue())) {
                    JadeThread.logInfo("Subside", "Dossier sourcier ! ==>" + membreFamille.getNomPrenom() + ";");
                } else {
                    JadeThread.logError("Subside",
                            "Pas de type de demande spécifiée ! ==>" + membreFamille.getNomPrenom() + ";");
                }
            }
        }
    }

    public boolean isDocumentAttrib(String noModel) {
        if (IAMCodeSysteme.AMDocumentModeles.DECMST1.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMST2.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMST3.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMST5.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMST8.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMPCM.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMPC7.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMISA.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMISC.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMIS1.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMASM.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMST10.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMST11.getValue().equals(noModel)
                || IAMCodeSysteme.AMDocumentModeles.DECMAS7.getValue().equals(noModel)) {
            return true;
        }
        return false;
    }

    private boolean isPersonneSeule(boolean isPersChargeSelon620) {
        // Si il n'y a pas de conjoint et pas d'enfant à charge, c'est une personne seule
        if (conjointValideExist()) {
            return false;
        }

        if (isPersChargeSelon620) {
            return false;
        }

        return true;
    }

    private boolean memberHasSubside(String idFamille) {
        try {
            SimpleDetailFamilleSearch sdfSearch = new SimpleDetailFamilleSearch();
            sdfSearch.setForIdFamille(idFamille);
            sdfSearch.setForCodeActif(true);
            sdfSearch = AmalImplServiceLocator.getSimpleDetailFamilleService().search(sdfSearch);

            for (JadeAbstractModel model : sdfSearch.getSearchResults()) {
                SimpleDetailFamille sdf = (SimpleDetailFamille) model;

                // Si le subside n'a pas de code de fin ET que c'est un document DECMST1, 2,3 ou 5, c'est qu'il a eu une
                // attribution
                if (JadeStringUtil.isBlankOrZero(sdf.getFinDroit())
                        && (IAMCodeSysteme.AMDocumentModeles.DECMST1.getValue().equals(sdf.getNoModeles())
                                || IAMCodeSysteme.AMDocumentModeles.DECMST2.getValue().equals(sdf.getNoModeles())
                                || IAMCodeSysteme.AMDocumentModeles.DECMST3.getValue().equals(sdf.getNoModeles())
                                || IAMCodeSysteme.AMDocumentModeles.DECMST5.getValue().equals(sdf.getNoModeles())
                                || IAMCodeSysteme.AMDocumentModeles.DECMST10.getValue().equals(sdf.getNoModeles()) || IAMCodeSysteme.AMDocumentModeles.DECMST11
                                .getValue().equals(sdf.getNoModeles()))) {
                    return true;
                }
            }
        } catch (Exception e) {
            JadeThread.logError("ERROR",
                    "Erreur lors de la recherche du dernier subside pour un membre né après la période fiscale !");
            JadeThread.logError("ERROR", e.getMessage());
        }
        return false;
    }

    private boolean revenuAlreadyExist(String idContribuable, String anneeHistorique) throws RevenuException,
            JadeApplicationServiceNotAvailableException, JadePersistenceException {
        // On va chercher si un revenu existe déjà, si c'est le cas, on ne va rien faire d'autre car
        // il ne faut pas ecraser la taxation utilisé actuellement.
        // On le fait lorsque le revenu est supérieur car si on a un subside, on sera "stoppé" par
        // la méthode "subsideDejaAttribue()" plus haut
        RevenuHistoriqueComplexSearch revenuHistoriqueSearch = new RevenuHistoriqueComplexSearch();
        revenuHistoriqueSearch.setForIdContribuable(this.idContribuable);
        revenuHistoriqueSearch.setForAnneeHistorique(anneeHistorique);
        revenuHistoriqueSearch.setForRevenuActif(true);
        revenuHistoriqueSearch = AmalServiceLocator.getRevenuService().search(revenuHistoriqueSearch);

        if (revenuHistoriqueSearch.getSize() > 0) {
            RevenuHistoriqueComplex rhc = (RevenuHistoriqueComplex) revenuHistoriqueSearch.getSearchResults()[0];

            if (!IAMCodeSysteme.AMTaxationType.PROVISOIRE.getValue().equals(
                    rhc.getRevenuFullComplex().getSimpleRevenu().getTypeTaxation())) {
                return true;
            }
        }

        return false;
    }

    @Override
    public void run() throws JadeApplicationException, JadePersistenceException {
        try {
            if (!"1".equals(currentTypeContribuable)) {
                if ("2".equals(currentTypeContribuable)) {
                    JadeThread
                            .logInfo("INFO", "Contribuable de type 'Confédéré' (typeCtr = 2) --> Aucune attribution;");
                } else if ("3".equals(currentTypeContribuable)) {
                    JadeThread.logInfo("INFO", "Contribuable de type 'Etranger' (typeCtr = 3) --> Aucune attribution;");
                } else if ("4".equals(currentTypeContribuable)) {
                    JadeThread.logInfo("INFO",
                            "Contribuable de type 'Parti-pour' (typeCtr = 4) --> Aucune attribution;");
                } else {
                    JadeThread.logInfo("INFO", "Contribuable de type inconnu (" + currentTypeContribuable
                            + ") --> Aucune attribution;");
                }
                return;
            }

            int nbPassage = 0;

            for (Iterator<String> it = mapTaxation.keySet().iterator(); it.hasNext();) {
                nbPassage++;
                String key = it.next();
                ch.globaz.amal.xmlns.am_0001._1.Taxation taxationXml = mapTaxation.get(key);
                BigInteger anneeTaxation = taxationXml.getPeriode();
                BigInteger anneeSubsideToSearch = anneeTaxation.add(new BigInteger("1"));
                BigInteger anneeHistorique = anneeTaxation.add(new BigInteger("2"));

                // Si l'année de taxation est supérieur au paramètre "yearTaxation", on ne fait rien
                if ((anneeTaxation.intValue() > yearTaxation)) {
                    JadeThread.logInfo("INFO", "Année de taxation (" + anneeTaxation.intValue()
                            + ") supérieure à l'année taxation MAX (" + yearTaxation + ");");
                    continue;
                }

                RevenuSearch revenuSearch = new RevenuSearch();
                revenuSearch.setForIdContribuable(idContribuable);
                revenuSearch.setForAnneeTaxation(anneeTaxation.toString());
                revenuSearch.setForTypeRevenu(IAMCodeSysteme.CS_TYPE_CONTRIBUABLE);
                ArrayList<String> listeTypesTaxation = new ArrayList<String>();
                if (isRepriseNonTaxes) {
                    listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.PROVISOIRE.getValue());
                } else {
                    listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.ORDINAIRE.getValue());
                    listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.OFFICE_TOTAUX.getValue());
                    listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.DECISION_NVL.getValue());
                    listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.DECISION_RCL.getValue());
                    listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.DECISION_REC.getValue());
                    listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.OFFICE_DETAIL.getValue());
                    listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.RECTIFICATION.getValue());
                    listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.RAPPEL_IMPOT.getValue());
                    listeTypesTaxation.add(IAMCodeSysteme.AMTaxationType.REVISION_TAX.getValue());
                }
                revenuSearch.setInTypeTaxation(listeTypesTaxation);
                revenuSearch.setOrderKey("orderByAnneeTaxationIdRevenu");
                revenuSearch = AmalServiceLocator.getRevenuService().search(revenuSearch);
                boolean ecChanged = false;
                boolean isPersChargeSelon620 = false;
                boolean familleModeste = false;
                boolean familleMoyenne = false;
                boolean revenuDefinitifExist = false;
                String idTaxation = "";
                if (revenuSearch.getSize() > 0) {
                    Revenu revenu = new Revenu();
                    revenu = (Revenu) revenuSearch.getSearchResults()[0];
                    idTaxation = revenu.getIdRevenu();

                    if (!isRepriseNonTaxes) {
                        revenuDefinitifExist = revenuAlreadyExist(idContribuable, anneeHistorique.toString());

                        if (!revenuDefinitifExist) {
                            CalculsSubsidesContainer c = new CalculsSubsidesContainer();
                            c.setAnneeHistorique(anneeHistorique.toString());
                            c.setIdContribuable(idContribuable);
                            c.setIdRevenu(idTaxation);
                            c.setRevenuIsTaxation(true);
                            c.setTypeDemande(IAMCodeSysteme.AMTypeDemandeSubside.REPRISE.getValue());
                            c.setSubsides(new ArrayList<SimpleDetailFamille>());
                            AmalServiceLocator.getDetailFamilleService().generateSubside(c,
                                    IAMCodeSysteme.AMJobType.JOBPROCESS.getValue(), false);
                            JadeThread.logInfo("INFO", "Revenu " + anneeHistorique + " non présent --> Création");
                        }

                        try {
                            isPersChargeSelon620 = !JadeStringUtil.isBlankOrZero(revenu.getPersChargeEnf());
                        } catch (Exception e) {
                            isPersChargeSelon620 = false;
                        }

                        ecChanged = checkIfEtatCivilChanged(taxationXml, ecChanged, anneeTaxation);

                        // -----------------------------------------------------------------------------------------
                        // Calcul du revenu déterminant
                        // -----------------------------------------------------------------------------------------
                        int revDet = calculRevDet(revenu.getIdRevenu(),
                                taxationXml.getPeriode().add(new BigInteger("2")));
                        int revenuMaxSubside = Integer.parseInt(containerParametres.getParametresAnnuelsProvider()
                                .getListeParametresAnnuels().get(IAMParametresAnnuels.CS_REVENU_MAX_SUBSIDE)
                                .getFormatedValueByYear(anneeHistorique.toString(), null, false, false, false, 0));
                        int rdu = new BigInteger(
                                JANumberFormatter.fmt(revenu.getRevDetUnique(), false, false, false, 0)).intValue();
                        if ((revDet > revenuMaxSubside) || ((rdu > revenuMaxSubside) && revenu.getRevDetUniqueOuiNon())) {
                            JadeThread.logInfo(
                                    "INFO",
                                    "Revenu déterminant ("
                                            + JANumberFormatter.fmt(String.valueOf(revDet), true, true, false, 2)
                                            + ") supérieur au revenu déterminant maximum ("
                                            + JANumberFormatter.fmt(String.valueOf(revenuMaxSubside), true, true,
                                                    false, 2) + ");");
                        }
                        int revenuMinSubside = Integer.parseInt(containerParametres.getParametresAnnuelsProvider()
                                .getListeParametresAnnuels().get(IAMParametresAnnuels.CS_REVENU_MIN_SUBSIDE)
                                .getFormatedValueByYear(anneeHistorique.toString(), null, false, false, false, 0));

                        if (IAMCodeSysteme.AMTaxationType.ORDINAIRE.getValue().equals(revenu.getTypeTaxation())) {
                            if (revDet < revenuMinSubside) {
                                familleModeste = true;
                            } else if ((revDet >= revenuMinSubside) && (revDet <= revenuMaxSubside)) {
                                familleMoyenne = true;
                            }
                        }
                    }
                }
                Map<String, String> noCaisseMaladieByMembre = new HashMap<String, String>();
                Map<String, String> subsidesByFamilyMember = new HashMap<String, String>();
                Map<String, SimpleFamille> mapFamilyMember = new HashMap<String, SimpleFamille>();
                Map<String, AMDocumentModeles> mapMembreModels = new HashMap<String, IAMCodeSysteme.AMDocumentModeles>();
                ArrayList<String> listMembersBornAfterFiscalPeriode = new ArrayList<String>();

                if ((familleModeste || familleMoyenne) || isRepriseNonTaxes) {
                    // On récupère les membres de la famille
                    SimpleFamilleSearch simpleFamilleSearch = new SimpleFamilleSearch();
                    simpleFamilleSearch.setForIdContribuable(idContribuable);
                    simpleFamilleSearch = AmalImplServiceLocator.getSimpleFamilleService().search(simpleFamilleSearch);

                    if (simpleFamilleSearch.getSize() > 0) {
                        for (JadeAbstractModel model : simpleFamilleSearch.getSearchResults()) {
                            SimpleFamille membreFamille = (SimpleFamille) model;
                            String idFamille = membreFamille.getIdFamille();

                            int ageMembre = checkAge(membreFamille, anneeHistorique);

                            boolean subsDejaPresent = subsideDejaAttribue(anneeHistorique, idFamille);

                            if (subsDejaPresent) {
                                JadeThread.logInfo("INFO", anneeHistorique + " : droit déjà présent membre "
                                        + membreFamille.getNomPrenom() + ";");
                                continue;
                            }

                            if (!JadeStringUtil.isBlankOrZero(membreFamille.getFinDefinitive())) {
                                JadeThread.logInfo("INFO",
                                        "Membre famille non traité car une date de fin est présente ! ("
                                                + membreFamille.getNomPrenom() + ");");
                                continue;
                            }

                            if (membreFamille.getPereMereEnfant().equals(IAMCodeSysteme.CS_TYPE_ENFANT)
                                    && JadeStringUtil.isBlankOrZero(membreFamille.getDateNaissance())) {
                                JadeThread.logWarn("WARN", "Enfant non traité car pas de date de naissance ! ("
                                        + membreFamille.getNomPrenom() + ");");
                                continue;
                            }

                            // si c'est un membre de famille qui n'était pas encore née pendant la période de taxation
                            int ageMembreTaxation = checkAge(membreFamille, anneeTaxation);
                            if (ageMembreTaxation <= 0) {
                                isMemberBornAfterFiscalPeriode = true;
                                listMembersBornAfterFiscalPeriode.add(membreFamille.getIdFamille());
                            }

                            SimpleDetailFamilleSearch detailFamilleSearch = new SimpleDetailFamilleSearch();
                            detailFamilleSearch.setForAnneeHistorique(anneeSubsideToSearch.toString());
                            detailFamilleSearch.setForIdContribuable(idContribuable);
                            detailFamilleSearch.setForIdFamille(membreFamille.getIdFamille());
                            detailFamilleSearch.setForRefus(false);
                            detailFamilleSearch.setForFinDroit("0");
                            detailFamilleSearch.setForCodeActif(true);
                            ArrayList<String> listeCodeTraitementDossiers = new ArrayList<String>();
                            listeCodeTraitementDossiers.add(IAMCodeSysteme.AMCodeTraitementDossier.COMPLET.getValue());
                            listeCodeTraitementDossiers.add(IAMCodeSysteme.AMCodeTraitementDossier.INCOMPLET.getValue());
                            listeCodeTraitementDossiers.add(IAMCodeSysteme.AMCodeTraitementDossier.TRAITE.getValue());
                            detailFamilleSearch.setInCodeTraitementDossier(listeCodeTraitementDossiers);
                            detailFamilleSearch.setOrderKey("orderByDroitDebut");
                            detailFamilleSearch = AmalImplServiceLocator.getSimpleDetailFamilleService().search(
                                    detailFamilleSearch);

                            // Si on est pas au 1er passage, il y a des chances pour qu'on ai attribué un document dans
                            // l'année précédente. Mais on ne va pas la trouver puisqu'il n'est pas encore envoyé. On va
                            // donc aller voir dans la table des controlleur envoi si on trouve un document
                            String noModelTemp = null;
                            if (nbPassage > 1) {
                                try {
                                    noModelTemp = checkTempModel(anneeSubsideToSearch, membreFamille, noModelTemp);
                                } catch (Exception ex) {
                                    JadeThread.logError("ERROR",
                                            "Erreur lors de la récupération du document temporaire pour l'année -1 --> idFamille : "
                                                    + membreFamille.getIdFamille() + " / Année historique : "
                                                    + anneeSubsideToSearch.toString() + ";");
                                    return;
                                }
                            }

                            getLastAttribution(familleModeste, familleMoyenne, noCaisseMaladieByMembre,
                                    subsidesByFamilyMember, mapFamilyMember, membreFamille, idFamille, ageMembre,
                                    detailFamilleSearch, noModelTemp);
                        }
                    }

                    // Parcours de tout les membres
                    AMDocumentModeles atsub = null;
                    String idFamilleContribuable = null;
                    for (String idFamille : subsidesByFamilyMember.keySet()) {
                        SimpleFamille membreFamille = mapFamilyMember.get(idFamille);

                        if (membreFamille.getIsContribuable()) {
                            idFamilleContribuable = membreFamille.getIdFamille();
                        }
                        // Si c'est un membre avec une PC, on saute
                        if ("PC_ASSISTE".equals(subsidesByFamilyMember.get(idFamille))) {
                            continue;
                        }

                        int ageMembre = checkAge(membreFamille, anneeHistorique);

                        if (subsidesByFamilyMember.get(idFamille).equals("NONE")
                                || subsidesByFamilyMember.get(idFamille).equals("OTHER")) {
                            // Pas eu d'attribution l'année d'avant
                            if (familleModeste) {
                                if (membreFamille.getIsContribuable()) {
                                    atsub = checkTypeATSUB(membreFamille, isPersChargeSelon620);
                                    mapMembreModels.put(idFamille, atsub);
                                } else {
                                    mapMembreModels.put(idFamille, null);
                                }
                            } else if (familleMoyenne) {
                                if (ageMembre <= 16) {
                                    mapMembreModels.put(idFamille, AMDocumentModeles.ATENF8);
                                }
                            } else {
                                mapMembreModels.put(idFamille, null);
                            }
                        } else {
                            if (familleModeste) {
                                if (membreFamille.getPereMereEnfant().equals(IAMCodeSysteme.CS_TYPE_ENFANT)
                                        && ((ageMembre >= 17) && (ageMembre <= 25))) {
                                    mapMembreModels.put(idFamille, AMDocumentModeles.ATENF1);
                                } else {
                                    if (!ecChanged) {
                                        mapMembreModels.put(idFamille, AMDocumentModeles.DECMST1);
                                    } else {
                                        if (membreFamille.getIsContribuable()) {
                                            atsub = checkTypeATSUB(membreFamille, isPersChargeSelon620);
                                            mapMembreModels.put(idFamille, atsub);
                                        } else {
                                            mapMembreModels.put(idFamille, null);
                                        }
                                    }
                                }
                            } else if (familleMoyenne) {
                                if ((ageMembre >= 17) && (ageMembre <= 25)) {
                                    mapMembreModels.put(idFamille, AMDocumentModeles.ATENF8);
                                } else if (ageMembre <= 16) {
                                    mapMembreModels.put(idFamille, AMDocumentModeles.DECMST8);
                                } else {
                                    mapMembreModels.put(idFamille, null);
                                }
                            } else if (isRepriseNonTaxes) {
                                if (membreFamille.getIsContribuable()) {
                                    mapMembreModels.put(idFamille, AMDocumentModeles.DECPRO1);
                                } else {
                                    mapMembreModels.put(idFamille, null);
                                }
                            } else {
                                mapMembreModels.put(idFamille, null);
                            }
                        }
                    }
                    // Si on a un ATSUBSX sur le contribuable principal, il faut supprimer les documents aux autres
                    // membres
                    if (atsub != null) {
                        for (String id : mapMembreModels.keySet()) {
                            if (idFamilleContribuable.equals(id)) {
                                mapMembreModels.put(id, atsub);
                            } else {
                                mapMembreModels.put(id, null);
                            }
                        }
                    }

                    // Si on a un membre né après la période fiscal, on n'envoie un ATSUBS au lieu d'un DECMST1 pour une
                    // famille modeste.
                    if (isMemberBornAfterFiscalPeriode) {
                        if (familleModeste) {
                            for (String id : mapMembreModels.keySet()) {
                                AMDocumentModeles model = mapMembreModels.get(id);
                                if (model == AMDocumentModeles.DECMST1) {
                                    if (idFamilleContribuable.equals(id)) {
                                        mapMembreModels.put(id, AMDocumentModeles.ATSUBS2);
                                        JadeThread
                                                .logInfo("INFO",
                                                        "DECMST1 remplacé par ATSUBS2 car enfant né après la période de taxation !");
                                    } else {
                                        mapMembreModels.put(id, null);
                                    }
                                }
                            }
                            // Et pour une famille moyenne, on envoie un atenf8 au lieu d'un decmst8
                        } else if (familleMoyenne) {
                            for (String id : mapMembreModels.keySet()) {
                                AMDocumentModeles model = mapMembreModels.get(id);
                                if (model == AMDocumentModeles.DECMST8) {
                                    if (listMembersBornAfterFiscalPeriode.contains(id) && !memberHasSubside(id)) {
                                        mapMembreModels.put(id, AMDocumentModeles.ATENF8);
                                        JadeThread
                                                .logInfo("INFO",
                                                        "DECMST8 remplacé par ATENF8 car enfant né après la période de taxation !");
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        if (familleModeste) {
                            // Pour les familles modestes (<33'000), si l'on a pas de document sur le contribuable
                            // principal, on ne doit pas en avoir ailleurs non plus!
                            checkFamilleModestDocumentOnContribPrincipal(mapMembreModels, idFamilleContribuable);
                        }
                    }

                    // Dernier contrôle, on va tester si les membres qui ont un DECMST1 ou DECMST8 ont un assureur. Si
                    // pas d'assureur, on n'envoie des ATSUBS, ou ATENF, à la place
                    checkDECMST1Or8HasCM(isPersChargeSelon620, familleModeste, familleMoyenne, noCaisseMaladieByMembre,
                            mapFamilyMember, mapMembreModels, idFamilleContribuable);
                }

                if (!JadeStringUtil.isBlankOrZero(idTaxation)) {
                    // 1) initialisation calculssubsidescontainer
                    CalculsSubsidesContainer currentCalculs = new CalculsSubsidesContainer(idContribuable,
                            anneeHistorique.toString(), IAMCodeSysteme.AMTypeDemandeSubside.REPRISE.getValue(),
                            idTaxation, true);

                    // 2) Travail avec les subsides, set noModeles et supplextra
                    int iNbZero = 0;
                    int iNbNotZero = 0;
                    for (int iSubside = 0; iSubside < currentCalculs.getSubsides().size(); iSubside++) {
                        SimpleDetailFamille currentSubside = currentCalculs.getSubsides().get(iSubside);
                        double subsideValue = 0.0;
                        try {
                            if (!JadeStringUtil.isBlankOrZero(currentSubside.getMontantContribSansSuppl())) {
                                subsideValue += Double.parseDouble(currentSubside.getMontantContribSansSuppl());
                                if (!JadeStringUtil.isEmpty(currentSubside.getMontantSupplement())) {
                                    subsideValue += Double.parseDouble(currentSubside.getMontantSupplement());
                                }
                            } else {
                                if (!JadeStringUtil.isBlankOrZero(currentSubside.getMontantContribution())) {
                                    subsideValue += Double.parseDouble(currentSubside.getMontantContribution());
                                }
                            }
                        } catch (Exception ex) {
                            ex.printStackTrace();
                        }
                        if (subsideValue > 0.0) {
                            iNbNotZero++;
                        } else {
                            iNbZero++;
                        }
                    }
                    for (int iSubside = 0; iSubside < currentCalculs.getSubsides().size(); iSubside++) {
                        SimpleDetailFamille currentSubside = currentCalculs.getSubsides().get(iSubside);
                        currentSubside.setTypeDemande(IAMCodeSysteme.AMTypeDemandeSubside.REPRISE.getValue());

                        double subsideValue = 0.0;

                        try {
                            if (!JadeStringUtil.isBlankOrZero(currentSubside.getMontantContribSansSuppl())) {
                                subsideValue += Double.parseDouble(currentSubside.getMontantContribSansSuppl());
                                if (!JadeStringUtil.isEmpty(currentSubside.getMontantSupplement())) {
                                    subsideValue += Double.parseDouble(currentSubside.getMontantSupplement());
                                }
                            } else {
                                if (!JadeStringUtil.isBlankOrZero(currentSubside.getMontantContribution())) {
                                    subsideValue += Double.parseDouble(currentSubside.getMontantContribution());
                                }
                            }
                        } catch (Exception ex) {
                            ex.printStackTrace();
                        }

                        if (mapMembreModels.get(currentSubside.getIdFamille()) != null) {
                            AMDocumentModeles document = mapMembreModels.get(currentSubside.getIdFamille());

                            if ((document == AMDocumentModeles.DECMST1) || (document == AMDocumentModeles.DECMST8)) {
                                try {
                                    if (JadeStringUtil.isBlankOrZero(currentSubside.getNoCaisseMaladie())) {
                                        String idCaisseMaladie = noCaisseMaladieByMembre.get(currentSubside
                                                .getIdFamille());
                                        currentSubside.setNoCaisseMaladie(idCaisseMaladie);
                                    }
                                } catch (Exception e) {
                                    currentSubside.setNoCaisseMaladie("0");
                                }
                            }

                            SimpleFamille membre = new SimpleFamille();
                            membre = AmalImplServiceLocator.getSimpleFamilleService().read(
                                    currentSubside.getIdFamille());

                            if (isRepriseNonTaxes) {
                                currentSubside.setRefus(false);
                                currentSubside.setNoModeles(document.getValue());
                                currentSubside.setSupplExtra("0");
                                currentSubside.setMontantContribution("0");
                                currentCalculs.getSubsides().set(iSubside, currentSubside);
                                JadeThread.logInfo("INFO", anneeHistorique + " : Attribution " + document.toString()
                                        + " membre " + membre.getNomPrenom() + ";");
                            } else {
                                boolean hasSubsideOnAnotherDossier = checkMemberHasAlreadySubside(currentSubside,
                                        membre);
                                if (hasSubsideOnAnotherDossier) {
                                    currentSubside.setRefus(true);
                                    continue;
                                }

                                if (iNbZero == 0) {
                                    currentSubside.setRefus(false);
                                    currentSubside.setNoModeles(document.getValue());
                                    currentSubside.setSupplExtra(currentSubside.getMontantSupplement());
                                    if (JadeStringUtil.isBlankOrZero(currentSubside.getMontantContribSansSuppl())) {
                                        currentSubside.setMontantContribution(currentSubside.getMontantContribution());
                                    } else {
                                        currentSubside.setMontantContribution(currentSubside
                                                .getMontantContribSansSuppl());
                                    }
                                    currentCalculs.getSubsides().set(iSubside, currentSubside);
                                    JadeThread.logInfo("INFO",
                                            anneeHistorique + " : Attribution " + document.toString() + " membre "
                                                    + membre.getNomPrenom() + ";");
                                } else {
                                    if (iNbNotZero == 0) {
                                        currentSubside.setRefus(true);
                                        currentSubside.setNoModeles(document.getValue());
                                        currentSubside.setSupplExtra(currentSubside.getMontantSupplement());
                                        if (JadeStringUtil.isBlankOrZero(currentSubside.getMontantContribSansSuppl())) {
                                            currentSubside.setMontantContribution(currentSubside
                                                    .getMontantContribution());
                                        } else {
                                            currentSubside.setMontantContribution(currentSubside
                                                    .getMontantContribSansSuppl());
                                        }
                                        currentCalculs.getSubsides().set(iSubside, currentSubside);
                                        JadeThread.logInfo("INFO",
                                                anneeHistorique + " : Attribution " + document.toString() + " membre "
                                                        + membre.getNomPrenom() + ";");
                                    } else {
                                        currentSubside.setRefus(false);
                                        currentSubside.setNoModeles(document.getValue());
                                        currentSubside.setSupplExtra(currentSubside.getMontantSupplement());
                                        if (JadeStringUtil.isBlankOrZero(currentSubside.getMontantContribSansSuppl())) {
                                            currentSubside.setMontantContribution(currentSubside
                                                    .getMontantContribution());
                                        } else {
                                            currentSubside.setMontantContribution(currentSubside
                                                    .getMontantContribSansSuppl());
                                        }
                                        currentCalculs.getSubsides().set(iSubside, currentSubside);
                                        JadeThread.logInfo("INFO",
                                                anneeHistorique + " : Attribution " + document.toString() + " membre "
                                                        + membre.getNomPrenom() + ";");
                                    }
                                }
                            }
                        } else {
                            currentCalculs.getSubsides().remove(iSubside);
                            iSubside--;
                        }
                    }
                    if (revenuDefinitifExist) {
                        JadeThread.logInfo("Info", "Revenu déjà existant pour l'année " + anneeHistorique);
                        // On set revenuIsTaxation pour ne pas modifier la taxation lié du revenu
                        currentCalculs.setRevenuIsTaxation(false);
                        // Et on efface les subside crées car on ne doit pas créer de subside si le revenu a déjà été
                        // calcul auparavant.
                        currentCalculs.getSubsides().clear();
                    }

                    // 3) Appel du service detailfamille.generatesubside
                    AmalServiceLocator.getDetailFamilleService().generateSubside(currentCalculs,
                            IAMCodeSysteme.AMJobType.JOBPROCESS.getValue(), false);
                } else {
                    JadeThread.logWarn("WARN", "Pas de taxation trouvée pour l'année " + anneeTaxation + ";");
                }
            }
        } catch (Exception e) {
            JadeThread.logError("ERREUR SUBSIDE", "ERREUR ENREGISTREMENT SUBSIDE ==>" + e.getMessage() + ";");
        } finally {
            currentContribuableConjoint = null;
            mapTaxation = null;
        }
    }

    @Override
    public void setCurrentEntity(JadeProcessEntity entity) {
        String idUpload = entity.getIdRef();
        SimpleUploadFichierReprise fileUploaded = null;
        try {
            fileUploaded = AmalServiceLocator.getSimpleUploadFichierService().read(idUpload);
            // Si plusieurs données dans custom values, voici la séquence :
            // idContribuable;nbEnfants;nbEnfantsSuspens;
            if (fileUploaded.getCustomValue().indexOf(";") >= 0) {
                String[] infos = fileUploaded.getCustomValue().split(";");
                idContribuable = infos[0];
            } else {
                idContribuable = fileUploaded.getCustomValue();
            }

            if (!JadeStringUtil.isEmpty(fileUploaded.getXmlLignes())) {
                StringBuffer ios = new StringBuffer(new StringBuffer(fileUploaded.getXmlLignes()));
                currentContribuables = (ch.globaz.amal.xmlns.am_0001._1.Contribuables) unmarshaller
                        .unmarshal(new StreamSource(new StringReader(ios.toString())));
                for (ch.globaz.amal.xmlns.am_0001._1.Contribuable c : currentContribuables.getContribuable()) {
                    currentTypeContribuable = c.getTypeCtr().toString();
                    for (ch.globaz.amal.xmlns.am_0001._1.Personne p : c.getPersonne()) {
                        if (ch.globaz.amal.xmlns.am_0001._1.TypePersonne.CONJOINT.equals(p.getType())) {
                            currentContribuableConjoint = p;
                        }
                    }
                    mapTaxation = new HashMap<String, ch.globaz.amal.xmlns.am_0001._1.Taxation>();
                    for (ch.globaz.amal.xmlns.am_0001._1.Taxation taxation : c.getTaxations().getTaxation()) {
                        mapTaxation.put(taxation.getPeriode().toString(), taxation);
                    }
                }
            }
            currentContribuables = null;
        } catch (Exception e) {
            currentContribuables = null;
        }

    }

    @Override
    public void setProperties(Map<Enum<?>, String> hashMap) {
        properties = hashMap;

        yearTaxation = Integer.parseInt(properties.get(AMProcessRepriseDecisionsTaxationsEnum.YEAR_TAXATION));
        yearSubside = Integer.parseInt(properties.get(AMProcessRepriseDecisionsTaxationsEnum.YEAR_SUBSIDE));
        if (properties.containsKey(AMProcessRepriseDecisionsTaxationsEnum.IS_FIN_ANNEE)) {
            isRepriseNonTaxes = true;
        }

    }

    /**
     * Retourne TRUE si un subside est trouvé avec comme document autre chose qu'un DECPRO .
     * 
     * @param anneeHistorique
     * @param idContribuable
     * @return
     */
    private boolean subsideDejaAttribue(BigInteger anneeHistorique, String idFamille) {
        try {
            SimpleDetailFamilleSearch subsSearch = new SimpleDetailFamilleSearch();
            subsSearch.setForAnneeHistorique(anneeHistorique.toString());
            subsSearch.setForIdFamille(idFamille);
            subsSearch.setForCodeActif(true);
            subsSearch = AmalImplServiceLocator.getSimpleDetailFamilleService().search(subsSearch);

            if (subsSearch.getSize() > 0) {
                for (JadeAbstractModel model_df : subsSearch.getSearchResults()) {
                    SimpleDetailFamille df = (SimpleDetailFamille) model_df;

                    // Si le document est vide (non attribué) ou si c'est un DECPRO, on n'a pas de subside attribué
                    boolean isDECPROOrZero = JadeStringUtil.isBlankOrZero(df.getNoModeles())
                            || IAMCodeSysteme.AMDocumentModeles.DECPRO1.getValue().equals(df.getNoModeles());

                    // Si le subside n'est pas refusé et qu'il n'a pas de fin de droit, il est actif
                    boolean isActif = !df.getRefus() && JadeStringUtil.isBlankOrZero(df.getFinDroit());

                    if (!isDECPROOrZero && isActif) {
                        return true;
                    }
                }
            }
        } catch (Exception ex) {
            return false;
        }
        return false;
    }

}